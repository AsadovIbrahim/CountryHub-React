'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var _classCallCheck = _interopDefault(require('babel-runtime/helpers/classCallCheck'));
var _createClass = _interopDefault(require('babel-runtime/helpers/createClass'));
var _possibleConstructorReturn = _interopDefault(require('babel-runtime/helpers/possibleConstructorReturn'));
var _inherits = _interopDefault(require('babel-runtime/helpers/inherits'));
var PropTypes = _interopDefault(require('prop-types'));
var fetches = require('fetches');
var _extends = _interopDefault(require('babel-runtime/helpers/extends'));
var isArray = _interopDefault(require('is-array'));
var _toConsumableArray = _interopDefault(require('babel-runtime/helpers/toConsumableArray'));
var isString = _interopDefault(require('is-string'));
var normalizeURL = _interopDefault(require('normalize-url'));
var _defineProperty = _interopDefault(require('babel-runtime/helpers/defineProperty'));
require('babel-runtime/regenerator');
require('babel-runtime/helpers/asyncToGenerator');

var FetchesContext = React.createContext({ client: null });

var cacheable = function cacheable(setCache) {
  return function (response) {
    setCache(response);
    return Promise.resolve(response);
  };
};

var getClient = function getClient(client, cache, setCache) {
  if (!cache) {
    return client;
  }
  return client.appendAfterMiddleware(cacheable(setCache));
};

var RequestWrapper = function (_React$Component) {
  _inherits(RequestWrapper, _React$Component);

  function RequestWrapper(props) {
    _classCallCheck(this, RequestWrapper);

    var _this = _possibleConstructorReturn(this, (RequestWrapper.__proto__ || Object.getPrototypeOf(RequestWrapper)).call(this, props));

    _initialiseProps.call(_this);

    _this.memoryAddress = JSON.stringify(props.uri);
    return _this;
  }

  _createClass(RequestWrapper, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var _props = this.props,
          client = _props.client,
          delay = _props.delay,
          pollInterval = _props.pollInterval,
          setCache = _props.setCache,
          cache = _props.cache;

      var setCacheWithAddress = setCache.bind(null, this.memoryAddress);
      var configuredClient = getClient(client, cache, setCacheWithAddress);
      console.log(configuredClient);
      var http = fetches.getHTTPMethods(configuredClient);
      if (pollInterval) {
        this.delayRequest().then(function () {
          _this2.interval = setInterval(function () {
            return _this2.resolvePromise(http);
          }, pollInterval);
        });
        return;
      }
      if (delay) {
        this.delayRequest().then(function () {
          return _this2.resolvePromise(http);
        });
        return;
      }
      this.resolvePromise(http);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unmounted = true;
      if (this.controller.abort) {
        this.controller.abort();
      }
      clearTimeout(this.timeout);
      clearInterval(this.interval);
    }
  }, {
    key: 'render',
    value: function render() {
      var children = this.props.children;
      var _state = this.state,
          loading = _state.loading,
          error = _state.error,
          data = _state.data;

      return children({
        loading: loading,
        error: error,
        data: data
      });
    }
  }]);

  return RequestWrapper;
}(React__default.Component);

var _initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this.controller = AbortController ? new AbortController() : {};
  this.timeout = null;
  this.interval = null;
  this.unmounted = false;
  this.memoryAddress = null;
  this.state = {
    loading: true,
    error: null,
    data: null
  };

  this.getRequest = function (http, uri, props) {
    var method = props.method,
        data = props.data,
        config = props.config;
    var signal = _this3.controller.signal;


    return http[method.toLowerCase()](uri, data, Object.assign({}, config, { signal: signal, cache: 'force-cache' }));
  };

  this.getStateResponse = function (error, data) {
    if (_this3.unmounted) {
      return null;
    }
    return _this3.setState({
      error: error,
      data: data,
      loading: false
    });
  };

  this.delayRequest = function () {
    var delay = _this3.props.delay;

    return new Promise(function (resolve) {
      _this3.timeout = setTimeout(function () {
        resolve();
      }, delay);
    });
  };

  this.resolvePromise = function (http) {
    _this3.handlePromise(http, _this3.props).then(function (data) {
      _this3.getStateResponse(null, data);
    }).catch(function (error) {
      _this3.getStateResponse(error, null);
    });
  };

  this.handlePromise = function (http, props) {
    var uri = props.uri,
        cache = props.cache,
        getCache = props.getCache;


    var cacheResult = getCache(_this3.memoryAddress);
    if (cache && cacheResult) {
      return Promise.resolve(cacheResult);
    }

    if (Array.isArray(uri)) {
      return _this3.handleMultiplePromises(http, props);
    }
    return _this3.handleSinglePromise(http, props);
  };

  this.handleSinglePromise = function (http, props) {
    var uri = props.uri;

    return _this3.getRequest(http, uri, props);
  };

  this.handleMultiplePromises = function (http, props) {
    var multipleMethod = props.multipleMethod,
        uri = props.uri;

    var promises = uri.map(function (item) {
      return _this3.getRequest(http, item, props);
    });
    return Promise[multipleMethod](promises);
  };
};

RequestWrapper.propTypes = {
  client: PropTypes.instanceOf(fetches.Client).isRequired,
  children: PropTypes.func.isRequired,
  uri: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).isRequired, // eslint-disable-line react/no-unused-prop-types
  method: PropTypes.oneOf(['get', 'post', 'patch', 'delete', 'put']).isRequired, // eslint-disable-line react/no-unused-prop-types
  multipleMethod: PropTypes.oneOf(['all', 'race']).isRequired, // eslint-disable-line react/no-unused-prop-types
  config: PropTypes.object.isRequired, // eslint-disable-line react/forbid-prop-types,react/no-unused-prop-types
  data: PropTypes.object.isRequired, // eslint-disable-line react/forbid-prop-types,react/no-unused-prop-types
  delay: PropTypes.number.isRequired,
  pollInterval: PropTypes.number.isRequired,
  cache: PropTypes.bool.isRequired
};

var Request = function Request(props) {
  var skip = props.skip,
      children = props.children,
      uri = props.uri,
      cache = props.cache;

  if (skip) {
    return children({ data: null, error: null, loading: false });
  }
  return React__default.createElement(
    FetchesContext.Consumer,
    null,
    function (_ref) {
      var client = _ref.client,
          setCache = _ref.setCache,
          getCache = _ref.getCache;
      return React__default.createElement(RequestWrapper, _extends({ client: client, getCache: getCache, setCache: setCache }, props));
    }
  );
};

Request.propTypes = {
  children: PropTypes.func.isRequired,
  uri: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
  method: PropTypes.oneOf(['get', 'post', 'patch', 'delete', 'put']),
  multipleMethod: PropTypes.oneOf(['all', 'race']),
  skip: PropTypes.bool,
  config: PropTypes.object, // eslint-disable-line react/forbid-prop-types
  data: PropTypes.object, // eslint-disable-line react/forbid-prop-types
  delay: PropTypes.number,
  pollInterval: PropTypes.number,
  cache: PropTypes.bool
};

Request.defaultProps = {
  uri: '',
  method: 'get',
  multipleMethod: 'all',
  skip: false,
  config: {},
  data: {},
  delay: 0,
  pollInterval: 0,
  cache: false
};

var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		Object.keys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	Object.keys(source).forEach(function(key) {
		if (!options.isMergeableObject(source[key]) || !target[key]) {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		} else {
			destination[key] = deepmerge(target[key], source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

var NOT_IMPLEMENTED = function NOT_IMPLEMENTED() {
  throw new Error('This method was not implemented yet');
};

var hasHTTPProtocol = function hasHTTPProtocol(url) {
  return isString(url) && url.startsWith('http');
};

var appendURL = function appendURL() {
  for (var _len = arguments.length, pieces = Array(_len), _key = 0; _key < _len; _key++) {
    pieces[_key] = arguments[_key];
  }

  return pieces.reduce(function (acc, current) {
    if (isArray(current)) {
      return acc + appendURL.apply(undefined, _toConsumableArray(current));
    }

    if (hasHTTPProtocol(current)) {
      return current;
    }

    return acc + '/' + current;
  }, '');
};

var normalizeURL$1 = (function () {
  for (var _len2 = arguments.length, pieces = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    pieces[_key2] = arguments[_key2];
  }

  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var completeURL = appendURL(pieces);
    var hasParams = !!completeURL.includes('?');
    return normalizeURL('' + completeURL + (hasParams ? '' : '/'), options);
  };
});

var DEFAULT_OPTIONS = {
  requestType: 'json',
  request: {},
  uri: {
    removeTrailingSlash: false
  },
  before: [],
  after: []
};

var Client = function () {
  function Client(uri) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Client);

    this.options = deepmerge_1(DEFAULT_OPTIONS, options);
    this.uri = normalizeURL$1(uri)(this.options.uri);

    if (this.options.requestType !== DEFAULT_OPTIONS.requestType) {
      NOT_IMPLEMENTED();
    }
    this.requestType = this.options.requestType;
  }

  _createClass(Client, [{
    key: 'getURI',
    value: function getURI() {
      return this.uri;
    }
  }, {
    key: 'getRequestType',
    value: function getRequestType() {
      return this.requestType;
    }
  }, {
    key: 'before',
    value: function before() {
      return this.options.before;
    }
  }, {
    key: 'after',
    value: function after() {
      return this.options.after;
    }
  }, {
    key: 'appendBeforeMiddleware',
    value: function appendBeforeMiddleware(middleware) {
      var options = deepmerge_1(this.options, {
        before: [middleware]
      });
      return new Client(this.getURI(), options);
    }
  }, {
    key: 'appendAfterMiddleware',
    value: function appendAfterMiddleware(middleware) {
      var options = deepmerge_1(this.options, {
        after: [middleware]
      });
      return new Client(this.getURI(), options);
    }
  }], [{
    key: 'appendToURI',
    value: function appendToURI(client) {
      var uri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      return normalizeURL$1([client.getURI(), uri])(client.options.uri);
    }
  }]);

  return Client;
}();

var Provider = function (_React$Component) {
  _inherits(Provider, _React$Component);

  function Provider() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Provider);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Provider.__proto__ || Object.getPrototypeOf(Provider)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      data: {}
    }, _this.setCache = function (url, data) {
      _this.setState(function (prevState) {
        return {
          data: _extends({}, prevState.data, _defineProperty({}, url, data))
        };
      });
    }, _this.getCache = function (url) {
      var data = _this.state.data;

      return data[url];
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Provider, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate() {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          client = _props.client,
          children = _props.children;

      return React__default.createElement(
        FetchesContext.Provider,
        { value: { client: client, setCache: this.setCache, getCache: this.getCache } },
        React__default.Children.only(children)
      );
    }
  }]);

  return Provider;
}(React__default.Component);

Provider.propTypes = {
  client: PropTypes.instanceOf(Client).isRequired,
  children: PropTypes.element.isRequired
};

exports.Request = Request;
exports.Provider = Provider;
